 
This is a set of programs to implement Fig-FORTH on an Arduino MEGA2560/1280 SBC. It brings together two applications with a third being used to provide the function of an 
"intersticial glue". The infrastructure of the language, its headers and linked lists, are provided by TASM run on dosemu. The code for the Arduino is provided by the Arduino
IDE. The file translation between the two is accomplished by gforth. 

There was a brief problem getting dosemu to work; it was shutting down after complaining of not being able to find the CD drive. I fixed this by making a symbolic link (sl) in the /media 
directory. Instructions on making symbolic links abound on the internet. I used "sudo sl name-of-thing-needed name-of-thing-to-be-linked-to". I originally used dosbox for running TASM
but after trying dosemu and finding it literally orders of magnitude faster I will not be going back.

The output file used by TASM is intel hex. It looks like this:
:1000000020000D970D8A0101610E1344000893C072
:10001000001F000F9340001F0000800080000D04AF
:1000200032E34A0C0000000000004669676475690D
:100030006E6F0000000000000000000000000000E3
and there is 16k of is that needs to be placed in an array (functioning as the ROM) in the Arduino's FLASH. This format can't be compiled directly and so had to be translated into
a form that would work for it. I elected to make an external Ardufigo.h file containing the array that was invoked by the Ardufigo.ino file. The Ardufigo.h file was translated from the 
Ardufigo.obj file which was generated by TASM. An excerpt looks like this:
const byte body[16384]  PROGMEM = {
0x20, 0x00, 0x0D, 0x97, 0x0D, 0x8A, 0x01, 0x01, 0x61, 0x0E, 0x13, 0x44, 0x00, 0x08, 0x93, 0xC0, //  .......a..D....
0x00, 0x1F, 0x00, 0x0F, 0x93, 0x40, 0x00, 0x1F, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x0D, 0x04, // .....@..........
0x32, 0xE3, 0x4A, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x69, 0x67, 0x64, 0x75, 0x69, // 2.J.......Figdui
0x6E, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // no..............
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x83, 0x4C, 0x49, 0x54, 0x00, 0x00, 0x01, 0x08, 0x00, 0x1B, 0x87, 0x45, 0x58, 0x45, 0x43, 0x55, // .LIT.......EXECU
0x54, 0x45, 0x01, 0x00, 0x01, 0x16, 0x00, 0x27, 0x86, 0x42, 0x52, 0x41, 0x4E, 0x43, 0x48, 0x01, // TE.....'.BRANCH.
0x0A, 0x01, 0x23, 0x00, 0x19, 0x87, 0x30, 0x42, 0x52, 0x41, 0x4E, 0x43, 0x48, 0x01, 0x18, 0x00, // ..#...0BRANCH...
0x1A, 0x86, 0x28, 0x4C, 0x4F, 0x4F, 0x50, 0x29, 0x01, 0x25, 0x01, 0x3C, 0x00, 0x39, 0x87, 0x28, // ..(LOOP).%.<.9.(
0x2B, 0x4C, 0x4F, 0x4F, 0x50, 0x29, 0x01, 0x31, 0x01, 0x4A, 0x00, 0x3A, 0x84, 0x28, 0x44, 0x4F, // +LOOP).1.J.:.(DO
0x29, 0x01, 0x3E, 0x01, 0x55, 0x00, 0x16, 0x82, 0x3E, 0x4C, 0x01, 0x4C, 0x01, 0x5E, 0x00, 0x43, // ).>.U...>L.L.^.C
0x82, 0x4C, 0x3E, 0x01, 0x57, 0x01, 0x67, 0x00, 0x44, 0x82, 0x4C, 0x3E, 0x01, 0x60, 0x01, 0x70, // .L>.W.g.D.L>.`.p
0x00, 0x48, 0x81, 0x49, 0x01, 0x69, 0x01, 0x78, 0x00, 0x1E, 0x85, 0x44, 0x49, 0x47, 0x49, 0x54, // .H.I.i.x...DIGIT
0x01, 0x72, 0x01, 0x84, 0x00, 0x00, 0x86, 0x28, 0x46, 0x49, 0x4E, 0x44, 0x29, 0x01, 0x7A, 0x01, // .r.....(FIND).z.
As can easily be seen this code comes much closer to being readable and is also compilable by the Arduino IDE. 

All of these programs are integrated by a script file running each program in succession and copying intermediate file forms into appropriate
 directories.

   The text parsing model is causing problems that, while repeatable, do not admit to any ready solution. I am writing an auxillary
routine to 'glue' ENCLOSE and WORD.
ENCLOSE leaves 4 stack entries. The first number is an offset that is added to IN. The next two are subtracted from each other to
create the length byte and the count of characters that are to be moved to HERE.

   It turns out that the problem above was the result of not putting the delimiter on the stack before calling WORD. I am amazed that
it worked at all. 